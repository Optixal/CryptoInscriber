#!/usr/bin/env python3

import argparse
import ccxt
import csv
import os
import sys
from time import sleep
from typing import Type, List


class Cleaner():

    def __init__(self):
        self.tradeDataPrev = None

    def dedup(self, tdCurr: dict, tdPrev: dict) -> dict:
        tdCurrIDs = [execution['id'] for execution in tdCurr]
        tdPrevLatestID = tdPrev[0]['id']
        if tdPrevLatestID not in tdCurrIDs:
            return tdCurr
        return tdCurr[:tdCurrIDs.index(tdPrev[0]['id'])]

    def convert(self, tradeData: dict) -> List[List]:
        converted = []
        for execution in tradeData:
            # ID, Timestamp, Price, Amount, Side
            converted.insert(0, [
                execution['id'],
                execution['timestamp'],
                execution['price'],
                execution['amount'],
                execution['side']
            ])
        return converted

    def clean(self, tradeData: dict):
        if self.tradeDataPrev:
            deduped = self.dedup(tradeData, self.tradeDataPrev)
        else:
            deduped = tradeData
        self.tradeDataPrev = tradeData
        return self.convert(deduped)


def buildParser() -> argparse.ArgumentParser:

    # Define Parser
    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        description='QuantDataOPTX | Cryptocurrency historical trade data poller'
    )

    # Exchange
    parser.add_argument('-e', '--exchange', metavar='bitstamp', required=True, help='cryptocurrency exchange name, see https://github.com/ccxt/ccxt#supported-cryptocurrency-exchange-markets for available exchanges')

    # Market's Symbol/Pair
    parser.add_argument('-m', '--market', metavar='BTC/USD', required=True, help='market symbol/pair to poll from')

    # Rate Limit Per Minute
    parser.add_argument('-r', '--rate', metavar='60', type=int, default=60, help='rate limit, max number or requests per minute')

    # Output Directory
    parser.add_argument('-o', '--output', metavar='out', default='out', help='output directory to store CSV files')

    return parser


def parseArgs(parser: argparse.ArgumentParser) -> argparse.Namespace:

    # Validate Args Length
    if len(sys.argv) < 2:
        parser.print_help()
        exit(1)

    # Parse
    args = parser.parse_args()
    return args


def getExchange(exchangeName: str) -> ccxt.Exchange:
    try:
        exchange = getattr(ccxt, exchangeName)()
    except AttributeError:
        print('Error: "{}" exchange is not available. Refer to https://github.com/ccxt/ccxt#supported-cryptocurrency-exchange-markets for available markets.'.format(exchangeName))
        exit(1)
    exchange.load_markets()
    return exchange


def createOutputDir(directory: str) -> None:
    if os.path.isdir(directory):
        return

    try:
        os.mkdir(directory)
    except FileExistsError:
        print('A non-directory item "{}" already exists. Please use another output name.'.format(directory))
        exit(1)


def getTradeData(exchange: ccxt.Exchange, market: str, customParams: dict = {}) -> List[dict]:
    return exchange.fetch_trades(market, params=customParams)


def writeCSV(data: List[List], filename: str) -> None:
    with open(filename, 'a') as f:
        fcsv = csv.writer(f)
        fcsv.writerows(data)


def main():
    try:
        parser   = buildParser()
        args     = parseArgs(parser)
        exchange = getExchange(args.exchange)
        market   = args.market.upper()
        delay    = 60 / args.rate
        cleaner  = Cleaner()
        createOutputDir(args.output)

        while True:
            print('Polling for trade data...')

            tradeData = getTradeData(exchange, market)
            cleanedData = cleaner.clean(tradeData)
            writeCSV(cleanedData, os.path.join(args.output, 'out.csv'))

            print('Recorded! Sleeping for {} seconds...'.format(delay))
            sleep(delay)

    except KeyboardInterrupt:
        pass


if __name__ == '__main__':
    main()
